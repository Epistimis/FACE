/*
 * generated by Xtext 2.30.0
 */
/*
 * Copyright (c) 2022, 2023 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.face.tests

import com.epistimis.face.face.ArchitectureModel
import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

@ExtendWith(InjectionExtension)
@InjectWith(FaceInjectorProvider)
class FaceParsingTest {
	@Inject
	ParseHelper<ArchitectureModel> parseHelper
	
	@Test
	def void loadModel() {
		val result = parseHelper.parse('''
am CommonCo ""{
	dm DataModel {
		cdm Structures {
	
			observable Question "A question that needs to be addressed";
			observable Answer  "The answer to a question";
			
			/**
			 * TODO: Can a CommonCo customer be someone other than the insured party? If so, what do we need to track to 
			 * determine that relationship and if appropriate authorizations are in place?
			 */
			centity Customer "The CommonCo customer. This may not be the insured party. " : PPT.Conceptual.NaturalPerson  {
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.NonPhysicalAddress 	phoneForText[0:1] 		"This specific phone used for texting";
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.NonPhysicalAddress 	phones[0:-1] 			"All phones. Any 'phoneForText' shoudl be here also";
				Privacy.General.AccessKey  															password[1:5] 			"password (history) - first is current, others are just so people don't repeat passwords";
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.Time.CalendarTime 	dob[1:1] 				"Date of birth";
				Privacy.General.Decision															privacyConsents[1:-1] 	"History of privacy consents";
				Privacy.General.Decision															termsCondsConsents[1:-1] "History of terms & conditions consents";				
				Insurance																			insurance[0:-1] 		"All the insurances the Customer has";
				QA																					qsAndAs[0:-1]			"All the questions asked by the customer (and their answers)";
			};

			/**
			 * Question content could be anything. Some content will be sensitive.
			 * 
			 * TODO: Do these questions have unique IDs? Or are they just addressed in list order? Generally, how do we deal with UniqueIDs -
			 * which are really an implementation detail
			 */
			centity QA "A customer question" {
				Question 																					question[1:1] 		"The question to answer";
				Privacy.People.Health																		medicalCondition[0:-1] "The medical condition this relates to, if any. Could be more than one";
				Answer   																					answer[0:-1]  		"The set of answers to the question";
				Privacy.General.Decision 																	decision[0:1] 		"If the question results in a decision, that is stored here.";
				QA																							subquestions[0:-1]  "One question may spur others";

				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.State.ConfigurationState 	sensitivity[0:1] 	"The sensitivity of this content. If not specified, this content is sensitive";
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.State.ValidityState 			validity[0:1] 		"How valid is this content. If not specified, the content is assumed to be valid";			
			};
			
			centity Advocate "A CommonCo advocate" : PPT.Conceptual.NaturalPerson {
				Customer																					customers[0:-1]		"All the customers for this Advocate";	
			};
			
			cassoc Insurance "Insurance Info" {
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.Identifier.Identifier group[1:1] "The group this is part of";
				Conceptual_Model.FACE_Shared_Data_Model_Conceptual.Observables.Identifier.Identifier member[1:1] "The member of the group";
				
				participants: [
				  PPT.Conceptual.LegalOrganization 	insuranceOrganization[1:1] "The insurance company" {src: [1:1]} ;
				  PPT.Conceptual.NaturalPerson 		insured[1:1] "The insured" {src: [1:1]} ;
				  PPT.Conceptual.NaturalPerson 		dependents[0:-1] "Dependents, if any. " {src: [1:1]} ;
				]														
			};
			

		}
		
		cdm Queries "The queries used for this model" {
			cquery FullCustomerRecord "All the Customer Data" {
				spec:"SELECT * FROM Customer"
			};
			cquery Login "Info needed for to log into an existing account" {
				spec:"SELECT Customer.name, Customer.password FROM Customer"
			};
			cquery BillingInfo "Info needed for billing" {
				spec: "SELECT Customer.name, Customer.address  FROM Customer"
				};
	 
			cquery Ack "Info needed for acknowledgement" {
				spec: "SELECT Customer.name FROM Customer"
			};

			cquery NewCustomerQuestion "Info for a question from Customer" {
				spec: "SELECT Customer.name, QA.question, QA.medicalCondition FROM Customer JOIN QA ON Customer.qsAndAs"
			};


			cquery RequestMore "Info needed for request" {
				spec: "SELECT QA.question as startingQ, QA.question as newQ FROM QA JOIN QA ON startingQ.subquestions = newQ"
			};
			
//			cquery AdvocateResponse "Question answered by Advocate" {
//				spec: "SELECT Customer.name, QA.* FROM Customer JOIN QA ON Customer.qsAndAs"
//			};
					
  			cquery RequestCustomerData "Info needed for customer Dashboard" {
				spec: "SELECT Customer.name FROM Customer"
			};

			/**
			 * Because this is just the answer associated with a question, it could be the main question or a subquestion -
			 * no matter who asks it.
			 */
			cquery NewAnswer "Info answering a question" {
				spec: "SELECT QA.question, QA.answer FROM QA "
			};
  
			cquery RequestListOfCustomers "All the customers associated with this Advocate" {
				spec: "SELECT Advocate.name FROM Advocate"
			};

			cquery RetrieveListOfCustomers "All the customers associated with this Advocate" {
				spec: "SELECT Customer.name FROM Customer JOIN Advocate ON Advocate.customers"
			};
			
			cquery RequestCustomerQuestionsList "Get all the questions associated with this Customer" {
				spec: "SELECT Customer.name FROM Customer"
			};
					
			cquery RetrieveCustomerQuestionsList "All info related to a specific customer question" {
				spec: "SELECT Customer.name, QA.question FROM Customer JOIN QA on Customer.qsAndAs"
			};

			cquery RequestQuestionDetail "Request detail on a question" {
				spec: "SELECT QA.question FROM QA"
			};
	
			cquery RetrieveQuestionDetail "All info related to a specific question" {
				spec: "SELECT QA.* FROM QA"
			};

		}
		
	}
}
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
}
