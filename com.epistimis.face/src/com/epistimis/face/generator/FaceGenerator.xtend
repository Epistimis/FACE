/*
 * generated by Xtext 2.28.0
 */
package com.epistimis.face.generator

import com.epistimis.face.face.UopClientServerConnection
import com.epistimis.face.face.UopCompositeTemplate
import com.epistimis.face.face.UopProgrammingLanguage
import com.epistimis.face.face.UopQueuingConnection
import com.epistimis.face.face.UopSingleInstanceMessageConnection
import com.epistimis.face.face.UopTemplate
import com.epistimis.face.face.UopTemplateComposition
import com.epistimis.face.face.UopUnitOfPortability
import com.epistimis.uddl.generator.QueryProcessor
import com.epistimis.uddl.query.query.QuerySpecification
import com.epistimis.uddl.uddl.PlatformCompositeQuery
import com.epistimis.uddl.uddl.PlatformEntity
import com.epistimis.uddl.uddl.PlatformQuery
import com.epistimis.uddl.uddl.PlatformQueryComposition
import com.google.inject.Inject
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.SortedMap
import java.util.TreeMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IResourceServiceProvider
import com.epistimis.uddl.scoping.IndexUtilities
import com.epistimis.face.face.UopConnection
import org.eclipse.emf.ecore.util.EcoreUtil
import java.text.MessageFormat

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FaceGenerator extends AbstractGenerator {

//	@Inject
//	IResourceServiceProvider.Registry reg;

	@Inject extension IQualifiedNameProvider qnp;
	@Inject extension IndexUtilities ndxUtil;

	@Inject extension QueryProcessor qp; 
	@Inject extension QueryUtilities qu;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		/**
//		 * Generate all the data structures
//		 */
//		val uddlGen = new UddlGenerator();
//		/** Eventually, we should only call the language specific generators directly for the selected entities referenced by
//		 * a UopUnitOfPortability - since we will also know which language to use (components are language specific)
//		 */
//		uddlGen.doGenerate(resource, fsa, context);

		// Make sure all cross references are resolved
		//EcoreUtil.resolveAll(resource.resourceSet);
		/**
		 * Set up the map of programming language specific generators
		 */
		val Map<UopProgrammingLanguage, IFaceLangGenerator> languageSpecificGenerators = new HashMap<UopProgrammingLanguage, IFaceLangGenerator>();
		languageSpecificGenerators.put(UopProgrammingLanguage.CPP, new CPPFunctionGenerator(qu));
		languageSpecificGenerators.put(UopProgrammingLanguage.GO, new GoFunctionGenerator(qu));
		languageSpecificGenerators.put(UopProgrammingLanguage.PYTHON, new PythonFunctionGenerator(qu));
		languageSpecificGenerators.put(UopProgrammingLanguage.SCALA, new ScalaFunctionGenerator(qu));
		languageSpecificGenerators.put(UopProgrammingLanguage.TS, new TypescriptFunctionGenerator(qu));
		

		/**
		 * Generate the functions
		 */
		for (comp : resource.allContents.toIterable.filter(UopUnitOfPortability)) {

			val List<PlatformEntity> entities = getReferencedEntities(comp);
			// Now call the relevant generator
			val generator = languageSpecificGenerators.get(comp.transportAPILanguage);
			if (generator === null) {
				val fmttedMessage = MessageFormat.format(
									"Component {0} is supposed to be generated in {1} but no generator yet available for that language",
									qnp.getFullyQualifiedName(comp).toString(), comp.transportAPILanguage.toString);

				System.out.println(fmttedMessage);
			} else {
				for (PlatformEntity entity : entities) {
					generator.processEntities(entities, fsa, context);
				}
				generator.processAComponent(comp, entities, fsa, context);
			}

		}

	}


}
