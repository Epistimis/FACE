/**
 * FACE Integration level - Epistimis extensions outside of the FACE spec
 */
import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/'
--import uddl : 'http://www.epistimis.com/uddl/Uddl/'
--import face : 'http://www.epistimis.com/face/Face/'
import 'platform:/plugin/com.epistimis.uddl/model/generated/Uddl.ecore'
import 'platform:/plugin/com.epistimis.face/model/generated/Face.ecore'

include 'platform:/plugin/com.epistimis.face/src/com/epistimis/face/constraints/uopExtensions.ocl'
include 'platform:/plugin/com.epistimis.face/src/com/epistimis/face/constraints/integration.ocl'

package face
				
	context IntegrationElement
	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/error.
		 */
		def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/warning. This doesn't 
		 * do anything but gives us two functions with similar names in case developers forget
		 * they can just use they inv return 'as is' for warnings.
		 */
		def: asWarning(verdict : Boolean) : Boolean = if verdict then true else false endif
				

	context IntegrationIntegrationContext
		def: allReferencedComponents(): Set(UopUnitOfPortability) =
			let dests = self.connection->collect(destination)->select(oclIsKindOf(face::IntegrationUoPInputEndPoint))->collect(oclAsType(face::IntegrationUoPInputEndPoint))  in
			let sources = self.connection->collect(source)->select(oclIsKindOf(face::IntegrationUoPOutputEndPoint))->collect(oclAsType(face::IntegrationUoPOutputEndPoint)) in
			let dcomps = dests->collect(connection)->collect(oclContainer) in
			let scomps = sources->collect(connection)->collect(oclContainer) in 		
			dcomps->asSet()->union(scomps->asSet())->collect(oclAsType(face::UopUnitOfPortability))->asSet()
	
		def: allReferencedPCs(): Set(UopPortableComponent) =
			self.allReferencedComponents()->selectByKind(UopPortableComponent)->collect(oclAsType(UopPortableComponent))->asSet()
	
		def: allReferencedPSCs(): Set(UopPlatformSpecificComponent) =
			self.allReferencedComponents()->selectByKind(UopPlatformSpecificComponent)->collect(oclAsType(UopPlatformSpecificComponent))->asSet()
	
		/**
		 * This approach checks for the interfaces actually used. The uop realized by the instances may define more interfaces
		 */
		def: referencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.connection->collect(referencedModelTypes())->asSet()
	
		def: referencesModelType(t: uddl::ConceptualComposableElement): Boolean =
			self.referencedModelTypes()->includes(t)
	
		def: allReferencedUopInstances(): Set(IntegrationUoPInstance) =
			let dests = self.connection->collect(destination)->select(oclIsKindOf(face::IntegrationUoPInputEndPoint))->collect(oclAsType(face::IntegrationUoPInputEndPoint))  in
			let sources = self.connection->collect(source)->select(oclIsKindOf(face::IntegrationUoPOutputEndPoint))->collect(oclAsType(face::IntegrationUoPOutputEndPoint)) in
			let dinsts = dests->collect(oclContainer) in
			let sinsts = sources->collect(oclContainer) in 		
			dinsts->asSet()->union(dinsts->asSet())->collect(oclAsType(IntegrationUoPInstance))->asSet()

		/**
		 * The entry points in an IntegrationContext 
		 */
		def: entryPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allReferencedUopInstances() in
			instances->select(entryPoint(self)) 

		/**
		 * ViewSource nodes are the entry nodes in an IntegrationContext 
		 * That seems to be their entire function
		 */
		def:entryNodes(): Set(face::IntegrationViewSource) =
			face::IntegrationViewSource.allInstances()->select(oclContainer = self)

		/**
		 * The exit points in an IntegrationContext.
		 */
		def: exitPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allReferencedUopInstances() in
			instances->select(exitPoint(self)) 

		/**
		 * ViewSink nodes are the exit nodes in an IntegrationContext 
		 * That seems to be their entire function
		 */
		def: exitNodes(): Set(face::IntegrationViewSink) =
			face::IntegrationViewSink.allInstances()->select(oclContainer = self)
			
		/**
		 * Follow the path of data through the graph.  For now, we just follow at the ConceptualEntity level because
		 * we aren't parsing queries close enough to pick out individual fields (use Java for that)
		 * To do this, we must follow links from upstream to downstream. We start with entryPoints and then find
		 * all their downstream instances. The possible consumers of data can only be in this set - so we just need
		 * to follow it. Alternatively, we can traverse node by node or UoPInstance by UoPInstance. 
		 * 
		 * The advantage of node by node is that we can filter out, at each step, the nodes that can be used, limiting 
		 * the combinatorial explosion. 
		 * 1) ViewSinks are a dead end - 
		 * 2) ViewFilter may be a dead end - check the downstream connected outPort
		 * 3) ViewTransporter is a pass through
		 * 4) ViewAggregation is a pass through
		 * 5) ViewTransformer
		 * 6) ViewSource - a starting point only
		 */
	
	context IntegrationTSNodeInputPort
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.view.referencedModelTypes()

		def: owner(): IntegrationTransportNode =
			self.oclContainer.oclAsType(IntegrationTransportNode)

		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.destination = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()

	context IntegrationTSNodeOutputPort
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.view.referencedModelTypes()

		def: owner(): IntegrationTransportNode =
			self.oclContainer.oclAsType(IntegrationTransportNode)

		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.source = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()

	context IntegrationUoPInputEndPoint
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.connection.referencedModelTypes()

		def: owner(): IntegrationUoPInstance =
			self.oclContainer.oclAsType(IntegrationUoPInstance)
			
		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.destination = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()

	context IntegrationUoPOutputEndPoint
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.connection.referencedModelTypes()
			
		def: owner(): IntegrationUoPInstance =
			self.oclContainer.oclAsType(IntegrationUoPInstance)
			
		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.source = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()
	
	context IntegrationUoPInstance 

		/**
		 * Is this an entry point in the specified IntegrationContext?
		 * That means it has no upstreams but has some downstreams somewhere (otherwise it isn't referenced
		 * at all).
		 */
		def: entryPoint(): Boolean =
			self.getLinkedUpstreamUoPInstances()->isEmpty() and
			self.getLinkedDownstreamUoPInstances()->notEmpty()

		/**
		 * Is this an exit point in the specified IntegrationContext?
		 * That means it has no downstreams but has some upstreams somewhere (otherwise it isn't referenced
		 * in the IC at all).
		 */
		def: exitPoint(): Boolean =
			self.getLinkedDownstreamUoPInstances()->isEmpty() and
			self.getLinkedUpstreamUoPInstances()->notEmpty() 

		/**
		 * Is this an entry point in the specified IntegrationContext?
		 * That means it has no upstreams but has some downstreams in this IC (otherwise it isn't referenced
		 * in the IC at all).
		 */
		def: entryPoint(ic: IntegrationIntegrationContext): Boolean =
			self.getLinkedUpstreamUoPInstances(ic)->isEmpty() and
			self.getLinkedDownstreamUoPInstances(ic)->notEmpty()

		/**
		 * Is this an exit point in the specified IntegrationContext?
		 * That means it has no downstreams but has some upstreams in this IC (otherwise it isn't referenced
		 * in the IC at all).
		 */
		def: exitPoint(ic: IntegrationIntegrationContext): Boolean =
			self.getLinkedDownstreamUoPInstances(ic)->isEmpty() and
			self.getLinkedUpstreamUoPInstances(ic)->notEmpty() 

		/**
		 * This approach checks for the interfaces actually used. The uop realized by the instances may define more interfaces
		 */
		def: actualReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			let inMsg = self.input->collect(getMessageType()) in
			let outMsg = self.output->collect(getMessageType()) in
			let inputs = inMsg->collect(referencedModelTypes()) in
			let outputs = outMsg->collect(referencedModelTypes()) in
--			let inputs = self.input->collect(referencedModelTypes())->asSet() in
--			let outputs = self.output->collect(referencedModelTypes())->asSet() in
			inputs->union(outputs)->asSet()

		/**
		 * Get only those types referenced on input/output - 
		 * NOTE: For ClientServerConnections, we need to retrieve either the Request or Response
		 * depending on the direction. That is handled by getMessageType()
		 */
		def: actualReferencedModelTypes(dir: UopMessageExchangeType): Set(uddl::ConceptualComposableElement) =
			if (dir = UopMessageExchangeType::INBOUND_MESSAGE) then
				self.input->collect(getMessageType())->collect(referencedModelTypes())->asSet() 
			else
				self.output->collect(getMessageType())->collect(referencedModelTypes())->asSet()
			endif
		
			
		def: actuallyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.actualReferencedModelTypes()->includes(t)
	
		/**
		 * This approach checks for the interfaces that could possibly be used. The instance interfaces may not use all of them
		 */
		def: possibleReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.realizes.referencedModelTypes()

		def: possibleReferencedModelTypes(dir: UopMessageExchangeType): Set(uddl::ConceptualComposableElement) =
			self.realizes.referencedModelTypes(dir)
	
		def: possiblyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.possibleReferencedModelTypes()->includes(t)
		
		/**
		 * This just linked UoPs - not the one this realizes
		 */	
		def: allReferencedUops(): Set(UopUnitOfPortability) =
			let inputs = self.input->collect(connection) in
			let outputs = self.output->collect(connection) in
			inputs->collect(owningUop())->union(outputs->collect(owningUop()))->asSet()
			

		/**
		 * Return the containment hierarchy of IntegrationModels as a Sequence - closest first
		 * this is effectively the same as how Scoping works
		 * 
		 * TODO: How do you cast an empty collection to the type you want?
		 */	
		def: containingIntegrationModels():Sequence(IntegrationIntegrationModel) =
			let container = self.oclContainer in
			if (not container.oclIsKindOf(IntegrationIntegrationModel)) then
				Sequence{}--:IntegrationIntegrationModel
			else
				let im = container.oclAsType(IntegrationIntegrationModel) in
				Sequence{im}->append(im.containingIntegrationModels())
			endif
			
			
	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "upstream" from a given IntegrationTransportNode.
	     */
	    def: getPreviousNodes() : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	                      ->select(c | self.input->includes(c.destination))
	                      ->collect(source)
	                      ->selectByKind(IntegrationTSNodeOutputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()

		/**
		 * Get all the previous nodes that are in the specified IntegrationContext
		 */
	    def: getPreviousNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getPreviousNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "downstream" from a given IntegrationTransportNode.
	     */
	    def: getNextNodes() : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	                      ->select(c | self.output->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationTSNodeInputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()


		/**
		 * Get all the next nodes that are in the specified IntegrationContext
		 */
	    def: getNextNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getNextNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

		/**
		 * Find all the integration contexts that reference this IC. They must all be contained
		 * in the (root) IntegrationModel that also contains this IC
		 */
--		def: referencingICs(): Set(IntegrationIntegrationContext) =
			
	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are immediately
	     * "upstream" from a given IntegrationUoPInstance. Note that this only traverses 1 link - 
	     * which may terminate at a TSNodePort => the result set may be empty.
	     */
	    def: getImmediatelyUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	                   self.getImmediatelyUpstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately previous UoPInstances that you can by following links in the
		 * specified IntegrationContext.Note that this only traverses 1 link - 
	     * which may terminate at a TSNodePort => the result set may be empty.
		 */
	    def: getImmediatelyUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in	      				 
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)

	    def: getImmediatelyUpstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
				   conns  ->select(c | self.input->includes(c.destination)) 
				     	  ->collect(source)
	                      ->selectByKind(IntegrationUoPOutputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()
			
				
	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are immediately
	     * "downstream" from a given IntegrationUoPInstance. Note that this only traverses 1 link - 
	     * which may terminate at a TSNodePort => the result set may be empty.
	     */
	    def: getImmediatelyDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately next UoPInstances that you can by following links in the
		 * specified IntegrationContext.Note that this only traverses 1 link - 
	     * which may terminate at a TSNodePort => the result set may be empty.
		 */
	    def: getImmediatelyDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)


	    def: getImmediatelyDownstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
	               conns  ->select(c | self.output->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationUoPInputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()


	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "upstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * upstream UoPInstances whose links to 'self' do not go through another UoPInstance).
	     */
	    def: getLinkedUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances() in
	    	let prevNodes = self.getPreviousNodes() in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances(ic) in
	    	let prevNodes = self.getPreviousNodes(ic) in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "downstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * downstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances() in
	    	let nextNodes = self.getNextNodes() in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances(ic) in
	    	let nextNodes = self.getNextNodes(ic) in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are
		 */
		def: getAllDownstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllDownstreamUoPInstances())
			)

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllDownstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllDownstreamUoPInstances(ic))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are
		 */
		def: getAllUpstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllUpstreamUoPInstances())
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllUpstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllUpstreamUoPInstances(ic))
			)
				
	/**
	 * Infrastructure for IntegrationIntegrationModel
	 */
	context IntegrationIntegrationModel
		/**
		 * Return the containment hierarchy of IntegrationModels as a Sequence - closest first
		 * this is effectively the same as how Scoping works
		 */	
		def: containingIntegrationModels():Sequence(IntegrationIntegrationModel) =
			let container = self.oclContainer in
			if (not container.oclIsKindOf(IntegrationIntegrationModel)) then
				Sequence{}--:IntegrationIntegrationModel
			else
				let im = container.oclAsType(IntegrationIntegrationModel) in
				Sequence{im}->append(im.containingIntegrationModels())
			endif

		/**
		 * Returns a flattened list of all the IntegrationModels nested in this one
		 */
		def: containedIMs():Set(IntegrationIntegrationModel) =
			self->closure(im)->asSet()
			
		/**
		 * Returns a set of all the IntegrationElements in all IMs (this one and all its nested IMs)
		 */
		def: containedElements(): Set(IntegrationElement) =
			self.containedIMs()->collect(element)->asSet()

		/**
		 * Returns a set of all the IntegrationTransportNodes in all IMs (this one and all its nested IMs)
		 */
		def: containedTransportNodes():Set(IntegrationTransportNode) =
			self.containedElements()->selectByKind(IntegrationTransportNode)

		/**
		 * Returns a set of all the IntegrationTSNodeConnections in all IMs (this one and all its nested IMs)
		 */
		def: containedTSNodeConnections():Set(IntegrationTSNodeConnection) =
			self.containedElements()->selectByKind(IntegrationTSNodeConnection)
		/**
		 * This looks at the interfaces actually used throughout the model. The referenced UoPs may define additional interfaces not used here.
		 */
		def: actualReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.element->selectByKind(IntegrationUoPInstance)->collect(actualReferencedModelTypes())->asSet()
	
		/**
		 * This looks at all the interfaces defined on all the UoPs referenced in the model. Some of those interfaces may not be used
		 */
		def: possibleReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.element->selectByKind(IntegrationUoPInstance)->collect(possibleReferencedModelTypes())->asSet()
		
		def: allIntegrationModels(): Set(IntegrationIntegrationModel) =
			self->closure(im)

		/**
		 * All the local UopInstances (does not include instances in nested models)
		 */
		def: allLocalUopInstances(): Set(IntegrationUoPInstance) =
			self.element->selectByKind(IntegrationUoPInstance)->asSet()
	
		/**
		 * All the IntegrationContexts (local and nested)
		 */
		def: allIntegrationContexts(): Set(IntegrationIntegrationContext) =
			let models = self.allIntegrationModels() in
				models->collect(element->selectByKind(IntegrationIntegrationContext))->asSet()
			
		/**
		 * All the UopInstances (local and nested)
		 */
		def: allUopInstances(): Set(IntegrationUoPInstance) =
			let models = self.allIntegrationModels() in
				models->collect(element->selectByKind(IntegrationUoPInstance))->asSet()

		def: allReferencedUops(): Set(UopUnitOfPortability) =
			self.allUopInstances()->collect(input.connection)->collect(allReferencedUops())->asSet()
			
		def: allReferencedPCs(): Set(UopPortableComponent) =
			self.allReferencedUops()->selectByKind(UopPortableComponent)->collect(oclAsType(UopPortableComponent))->asSet()
	
		def: allReferencedPSCs(): Set(UopPlatformSpecificComponent) =
			self.allReferencedUops()->selectByKind(UopPlatformSpecificComponent)->collect(oclAsType(UopPlatformSpecificComponent))->asSet()
	
		def: actuallyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.actualReferencedModelTypes()->includes(t)
	
		def: possiblyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.possibleReferencedModelTypes()->includes(t)
	
		/**
		 * The entry points in an IntegrationModel (local and nested)
		 */
		def: entryPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allUopInstances() in
			instances->select(entryPoint()) 

		/**
		 * Returns a set of all the IntegrationViewSources in all IMs (this one and all its nested IMs)
		 */
		def: containedEntryNodes():Set(IntegrationViewSource) =
			self.containedTransportNodes()->selectByKind(IntegrationViewSource)
			
		/**
		 * Returns a set of all the IntegrationViewSinks in all IMs (this one and all its nested IMs)
		 */
		def: containedExitNodes():Set(IntegrationViewSink) =
			self.containedTransportNodes()->selectByKind(IntegrationViewSink)

		/**
		 * ViewSource nodes are the entry nodes in an IntegrationModel 
		 * That seems to be their entire function
		 */
		def:entryNodes(): Set(face::IntegrationViewSource) =
			face::IntegrationViewSource.allInstances()->select(oclContainer = self)
		/**
		 * The exit points in an IntegrationModel (local and nested)
		 */
		def: exitPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allUopInstances() in
			instances->select(exitPoint()) 
	
		/**
		 * ViewSink nodes are the exit nodes in an IntegrationModel 
		 * That seems to be their entire function
		 */
		def:exitNodes(): Set(face::IntegrationViewSink) =
			face::IntegrationViewSink.allInstances()->select(oclContainer = self)
	
	  context IntegrationTSNodeConnection
	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "upstream" from a given IntegrationTransportNode. Result set will be empty if
	     * immediate upstream nodes are TSNodePorts.
	     */
	    def: getImmediatelyUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
		      self.source
	                      ->selectByKind(IntegrationUoPOutputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "downstream" from a given IntegrationTransportNode.Result set will be empty if
	     * immediate upstream nodes are TSNodePorts
	     */
	    def: getImmediatelyDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      		self.destination
	                      ->selectByKind(IntegrationUoPInputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()
	  

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "upstream" from a given IntegrationTransportNode.
	     */
	    def: getPreviousNodes() : Set(IntegrationTransportNode) =
	      			self.source
	                      ->selectByKind(IntegrationTSNodeOutputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()

		/**
		 * Get all the previous nodes that are in the specified IntegrationContext
		 */
	    def: getPreviousNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getPreviousNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "downstream" from a given IntegrationTransportNode.
	     */
	    def: getNextNodes() : Set(IntegrationTransportNode) =
	      			self.destination
	                      ->selectByKind(IntegrationTSNodeInputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()


		/**
		 * Get all the next nodes that are in the specified IntegrationContext
		 */
	    def: getNextNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getNextNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "upstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * upstream UoPInstances whose links to 'self' do not go through another UoPInstance).
	     * 
	     * NOTE: This assumes the IntegrationContext of the starting link
	     */
	    def: getLinkedUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let ic = self.oclContainer.oclAsType(IntegrationIntegrationContext) in
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances() in
	    	let prevNodes = self.getPreviousNodes(ic) in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "downstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * downstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     * 
	     * NOTE: This assumes the IntegrationContext of the starting link
	     *
	     */
	    def: getLinkedDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let ic = self.oclContainer.oclAsType(IntegrationIntegrationContext) in
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances() in
	    	let nextNodes = self.getNextNodes(ic) in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	  context IntegrationTSNodePortBase
	    /*
	     * Helper method that gets the IntegrationTransportNode containing a given
	     * IntegrationTSNodePortBase
	     */
	    def: getParentUoPInstance() : IntegrationUoPInstance =
	      IntegrationUoPInstance.allInstances()->select(inst | inst.input->includes(self) or
	                                                inst.output = self)
	                                  ->any(true)
	
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			if (self.oclIsKindOf(face::IntegrationTSNodeOutputPort)) then
				self.oclAsType(face::IntegrationTSNodeOutputPort).referencedModelTypes()
			else
				if (self.oclIsKindOf(face::IntegrationTSNodeInputPort)) then
					self.oclAsType(face::IntegrationTSNodeInputPort).referencedModelTypes()
				else
					if (self.oclIsKindOf(face::IntegrationUoPOutputEndPoint)) then
						self.oclAsType(face::IntegrationUoPOutputEndPoint).referencedModelTypes()
					else
--						if (self.oclIsKindOf(face::IntegrationUoPInputEndPoint)) then
							self.oclAsType(face::IntegrationUoPInputEndPoint).referencedModelTypes()
--						endif
					endif
				endif
			endif
	
	  context IntegrationTransportNode

		def: owner(): IntegrationIntegrationContext =
			self.oclContainer.oclAsType(IntegrationIntegrationContext)

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "upstream" from a given IntegrationTransportNode that you can get to by following links 
	     * in the specified IntegrationContext
	     */
	    def: getPreviousNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	 	      			  ->select(c | c.oclContainer = ic)
	                      ->select(c | self.inPort->includes(c.destination))
	                      ->collect(source)
	                      ->selectByKind(IntegrationTSNodeOutputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()
	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "downstream" from a given IntegrationTransportNode that you can get to by following links 
	     * in the specified IntegrationContext
	     */
	    def: getNextNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	 	      			  ->select(c | c.oclContainer = ic) 
	                      ->select(c | self.outPort->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationTSNodeInputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "upstream" from a given IntegrationTransportNode.
	     */
	    def: getImmediatelyUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in	      				 
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)
	                      

	    def: getImmediatelyUpstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
				   conns  ->select(c | self.inPort->includes(c.destination)) 
				     	  ->collect(source)
	                      ->selectByKind(IntegrationUoPOutputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "downstream" from a given IntegrationTransportNode.
	     */
	    def: getImmediatelyDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)


	    def: getImmediatelyDownstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
	               conns  ->select(c | self.outPort->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationUoPInputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()

		/*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "upstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * upstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances() in
	    	let prevNodes = self.getPreviousNodes() in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances(ic) in
	    	let prevNodes = self.getPreviousNodes(ic) in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "downstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * downstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances() in
	    	let nextNodes = self.getNextNodes() in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances(ic) in
	    	let nextNodes = self.getNextNodes(ic) in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()
	
	
		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are
		 */
		def: getAllDownstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllDownstreamUoPInstances()))
			)

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllDownstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllDownstreamUoPInstances(ic)))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are.
		 */
		def: getAllUpstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllUpstreamUoPInstances()))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllUpstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllUpstreamUoPInstances(ic)))
			)

		/**
		 * Get the referenced model types. These only exist within an IC, so everything that is there is used
		 */
		def: referencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			let inMsg = self.inPort->collect(getMessageType()) in
			let outMsg = self.outPort->collect(getMessageType()) in
			let inputs = inMsg->collect(referencedModelTypes()) in
			let outputs = outMsg->collect(referencedModelTypes()) in
			inputs->union(outputs)->asSet()

				
endpackage
