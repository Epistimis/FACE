/**
 * FACE Integration level - Epistimis extensions outside of the FACE spec
 */
import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/'
--import uddl : 'http://www.epistimis.com/uddl/Uddl/'
--import face : 'http://www.epistimis.com/face/Face/'
import 'platform:/plugin/com.epistimis.uddl/model/generated/Uddl.ecore'
import 'platform:/plugin/com.epistimis.face/model/generated/Face.ecore'

include 'platform:/plugin/com.epistimis.face/src/com/epistimis/face/constraints/uopExtensions.ocl'
include 'platform:/plugin/com.epistimis.face/src/com/epistimis/face/constraints/integration.ocl'

package face
				
	context IntegrationElement
	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/error.
		 */
		def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/warning. This doesn't 
		 * do anything but gives us two functions with similar names in case developers forget
		 * they can just use they inv return 'as is' for warnings.
		 */
		def: asWarning(verdict : Boolean) : Boolean = if verdict then true else false endif
				

	context IntegrationIntegrationContext
		def: allReferencedComponents(): Set(UopUnitOfPortability) =
			let dests = self.connection->collect(destination)->select(oclIsKindOf(face::IntegrationUoPInputEndPoint))->collect(oclAsType(face::IntegrationUoPInputEndPoint))  in
			let sources = self.connection->collect(source)->select(oclIsKindOf(face::IntegrationUoPOutputEndPoint))->collect(oclAsType(face::IntegrationUoPOutputEndPoint)) in
			let dcomps = dests->collect(connection)->collect(oclContainer) in
			let scomps = sources->collect(connection)->collect(oclContainer) in 		
			dcomps->asSet()->union(scomps->asSet())->collect(oclAsType(face::UopUnitOfPortability))->asSet()
	
		def: allReferencedPCs(): Set(UopPortableComponent) =
			self.allReferencedComponents()->selectByKind(UopPortableComponent)->collect(oclAsType(UopPortableComponent))->asSet()
	
		def: allReferencedPSCs(): Set(UopPlatformSpecificComponent) =
			self.allReferencedComponents()->selectByKind(UopPlatformSpecificComponent)->collect(oclAsType(UopPlatformSpecificComponent))->asSet()
	
		/**
		 * This approach checks for the interfaces actually used. The uop realized by the instances may define more interfaces
		 */
		def: referencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.connection->collect(referencedModelTypes())->asSet()
	
		def: referencesModelType(t: uddl::ConceptualComposableElement): Boolean =
			self.referencedModelTypes()->includes(t)
	
		def: allReferencedUopInstances(): Set(IntegrationUoPInstance) =
			let dests = self.connection->collect(destination)->select(oclIsKindOf(face::IntegrationUoPInputEndPoint))->collect(oclAsType(face::IntegrationUoPInputEndPoint))  in
			let sources = self.connection->collect(source)->select(oclIsKindOf(face::IntegrationUoPOutputEndPoint))->collect(oclAsType(face::IntegrationUoPOutputEndPoint)) in
			let dinsts = dests->collect(oclContainer) in
			let sinsts = sources->collect(oclContainer) in 		
			dinsts->asSet()->union(dinsts->asSet())->collect(oclAsType(IntegrationUoPInstance))->asSet()

		/**
		 * The entry points in an IntegrationContext are all those instances that have no 
		 * other instances upstream
		 */
		def: entryPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allReferencedUopInstances() in
			instances->select(getImmediatelyUpstreamUoPInstances(self)->isEmpty()) 

		/**
		 * The exit points in an IntegrationContext are all those instances that have no 
		 * other instances upstream
		 */
		def: exitPoints(): Set(IntegrationUoPInstance) =
			let instances = self.allReferencedUopInstances() in
			instances->select(getImmediatelyDownstreamUoPInstances(self)->isEmpty()) 
	
	context IntegrationUoPInputEndPoint
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.connection.referencedModelTypes()

		def: owner(): IntegrationUoPInstance =
			self.oclContainer.oclAsType(IntegrationUoPInstance)
			
		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.destination = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()

	context IntegrationUoPOutputEndPoint
		def: referencedModelTypes():Set(uddl::ConceptualComposableElement) =
			self.connection.referencedModelTypes()
			
		def: owner(): IntegrationUoPInstance =
			self.oclContainer.oclAsType(IntegrationUoPInstance)
			
		def: linksInIC(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			ic.connection->select(l|l.source = self)->asSet()

		def: linksInIM(ic: IntegrationIntegrationContext): Set(IntegrationTSNodeConnection) =
			let model = self.owner().oclContainer.oclAsType(IntegrationIntegrationModel) in
			let ics = model.element->select(oclIsKindOf(face::IntegrationIntegrationContext)) in
			ics->iterate(ic: IntegrationIntegrationContext; result:Set(IntegrationTSNodeConnection) = Set{} |
				result->includingAll(self.linksInIC(ic))
			)->asSet()
	
	context IntegrationUoPInstance 

		/**
		 * Is this an entry point in the specified IntegrationContext?
		 */
		def: entryPoint(ic: IntegrationIntegrationContext): Boolean =
			self.getImmediatelyUpstreamUoPInstances(ic)->isEmpty() 

		/**
		 * Is this an exit point in the specified IntegrationContext?
		 */
		def: exitPoint(ic: IntegrationIntegrationContext): Boolean =
			self.getImmediatelyDownstreamUoPInstances(ic)->isEmpty() 

		/**
		 * This approach checks for the interfaces actually used. The uop realized by the instances may define more interfaces
		 */
		def: actualReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			let inputs = self.input->collect(referencedModelTypes())->asSet() in
			let outputs = self.output->collect(referencedModelTypes())->asSet() in
			inputs->union(outputs)->asSet()
			
		def: actuallyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.actualReferencedModelTypes()->includes(t)
	
		/**
		 * This approach checks for the interfaces that could possibly be used. The instance interfaces may not use all of them
		 */
		def: possibleReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.realizes.referencedModelTypes()
	
		def: possiblyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.possibleReferencedModelTypes()->includes(t)
		
		/**
		 * This just linked UoPs - not the one this realizes
		 */	
		def: allReferencedUops(): Set(UopUnitOfPortability) =
			let inputs = self.input->collect(connection) in
			let outputs = self.output->collect(connection) in
			inputs->collect(owningUop())->union(outputs->collect(owningUop()))->asSet()
			

		/**
		 * Return the containment hierarchy of IntegrationModels as a Sequence - closest first
		 * this is effectively the same as how Scoping works
		 * 
		 * TODO: How do you cast an empty collection to the type you want?
		 */	
		def: containingIntegrationModels():Sequence(IntegrationIntegrationModel) =
			let container = self.oclContainer in
			if (not container.oclIsKindOf(IntegrationIntegrationModel)) then
				Sequence{}--:IntegrationIntegrationModel
			else
				let im = container.oclAsType(IntegrationIntegrationModel) in
				Sequence{im}->append(im.containingIntegrationModels())
			endif
			
			
	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "upstream" from a given IntegrationTransportNode.
	     */
	    def: getPreviousNodes() : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	                      ->select(c | self.input->includes(c.destination))
	                      ->collect(source)
	                      ->selectByKind(IntegrationTSNodeOutputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()

		/**
		 * Get all the previous nodes that are in the specified IntegrationContext
		 */
	    def: getPreviousNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getPreviousNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "downstream" from a given IntegrationTransportNode.
	     */
	    def: getNextNodes() : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	                      ->select(c | self.output->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationTSNodeInputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()


		/**
		 * Get all the next nodes that are in the specified IntegrationContext
		 */
	    def: getNextNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	    	let rawNodes = self.getNextNodes() in
	    		rawNodes->select(n| n.oclContainer = ic)

		/**
		 * Find all the integration contexts that reference this IC. They must all be contained
		 * in the (root) IntegrationModel that also contains this IC
		 */
--		def: referencingICs(): Set(IntegrationIntegrationContext) =
			
	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are immediately
	     * "upstream" from a given IntegrationUoPInstance.
	     */
	    def: getImmediatelyUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	                   self.getImmediatelyUpstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in	      				 
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)

	    def: getImmediatelyUpstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
				   conns  ->select(c | self.input->includes(c.destination)) 
				     	  ->collect(source)
	                      ->selectByKind(IntegrationUoPOutputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()
			
				
	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are immediately
	     * "downstream" from a given IntegrationUoPInstance.
	     */
	    def: getImmediatelyDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)


	    def: getImmediatelyDownstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
	               conns  ->select(c | self.output->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationUoPInputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()


	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "upstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * upstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances() in
	    	let prevNodes = self.getPreviousNodes() in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances(ic) in
	    	let prevNodes = self.getPreviousNodes(ic) in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "downstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * downstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances() in
	    	let nextNodes = self.getNextNodes() in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances(ic) in
	    	let nextNodes = self.getNextNodes(ic) in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are
		 */
		def: getAllDownstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllDownstreamUoPInstances())
			)

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllDownstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllDownstreamUoPInstances(ic))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are
		 */
		def: getAllUpstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllUpstreamUoPInstances())
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllUpstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst.getAllUpstreamUoPInstances(ic))
			)
				
	/**
	 * Infrastructure for IntegrationIntegrationModel
	 */
	context IntegrationIntegrationModel
		/**
		 * Return the containment hierarchy of IntegrationModels as a Sequence - closest first
		 * this is effectively the same as how Scoping works
		 */	
		def: containingIntegrationModels():Sequence(IntegrationIntegrationModel) =
			let container = self.oclContainer in
			if (not container.oclIsKindOf(IntegrationIntegrationModel)) then
				Sequence{}--:IntegrationIntegrationModel
			else
				let im = container.oclAsType(IntegrationIntegrationModel) in
				Sequence{im}->append(im.containingIntegrationModels())
			endif


		/**
		 * This looks at the interfaces actually used throughout the model. The referenced UoPs may define additional interfaces not used here.
		 */
		def: actualReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.element->selectByKind(IntegrationUoPInstance)->collect(actualReferencedModelTypes())->asSet()
	
		/**
		 * This looks at all the interfaces defined on all the UoPs referenced in the model. Some of those interfaces may not be used
		 */
		def: possibleReferencedModelTypes(): Set(uddl::ConceptualComposableElement) =
			self.element->selectByKind(IntegrationUoPInstance)->collect(possibleReferencedModelTypes())->asSet()
		
		def: allUopInstances(): Set(IntegrationUoPInstance) =
			self.element->selectByKind(IntegrationUoPInstance)->asSet()
	
		def: allReferencedUops(): Set(UopUnitOfPortability) =
			self.allUopInstances()->collect(input.connection)->collect(allReferencedUops())->asSet()
			
		def: allReferencedPCs(): Set(UopPortableComponent) =
			self.allReferencedUops()->selectByKind(UopPortableComponent)->collect(oclAsType(UopPortableComponent))->asSet()
	
		def: allReferencedPSCs(): Set(UopPlatformSpecificComponent) =
			self.allReferencedUops()->selectByKind(UopPlatformSpecificComponent)->collect(oclAsType(UopPlatformSpecificComponent))->asSet()
	
		def: actuallyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.actualReferencedModelTypes()->includes(t)
	
		def: possiblyReferencesModelType(t: uddl::ConceptualObservable): Boolean =
			self.possibleReferencedModelTypes()->includes(t)
	
		def: allIntegrationContexts(): Set(IntegrationIntegrationContext) =
			let localICs = self.element->selectByType(IntegrationIntegrationContext)->asSet() in
			let localIMs = self.element->selectByType(IntegrationIntegrationModel) in
			let subICs = localIMs->collect(allIntegrationContexts())->flatten() in
			localICs->union(subICs)->asSet()
			
		def: allIntegrationModels(): Set(IntegrationIntegrationModel) =
			self->closure(im)

	  context IntegrationTSNodePortBase
	    /*
	     * Helper method that gets the IntegrationTransportNode containing a given
	     * IntegrationTSNodePortBase
	     */
	    def: getParentUoPInstance() : IntegrationUoPInstance =
	      IntegrationUoPInstance.allInstances()->select(inst | inst.input->includes(self) or
	                                                inst.output = self)
	                                  ->any(true)
	
	  context IntegrationTransportNode

	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "upstream" from a given IntegrationTransportNode that you can get to by following links 
	     * in the specified IntegrationContext
	     */
	    def: getPreviousNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	 	      			  ->select(c | c.oclContainer = ic)
	                      ->select(c | self.inPort->includes(c.destination))
	                      ->collect(source)
	                      ->selectByKind(IntegrationTSNodeOutputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()
	    /*
	     * Helper method that gets the set of TransportNodes that are
	     * "downstream" from a given IntegrationTransportNode that you can get to by following links 
	     * in the specified IntegrationContext
	     */
	    def: getNextNodes(ic: IntegrationIntegrationContext) : Set(IntegrationTransportNode) =
	      IntegrationTSNodeConnection.allInstances()
	 	      			  ->select(c | c.oclContainer = ic) 
	                      ->select(c | self.outPort->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationTSNodeInputPort)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentTransportNode())
	                      ->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "upstream" from a given IntegrationTransportNode.
	     */
	    def: getImmediatelyUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in	      				 
		               self.getImmediatelyUpstreamUoPInstancesImpl(conns)
	                      

	    def: getImmediatelyUpstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
				   conns  ->select(c | self.inPort->includes(c.destination)) 
				     	  ->collect(source)
	                      ->selectByKind(IntegrationUoPOutputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are
	     * "downstream" from a given IntegrationTransportNode.
	     */
	    def: getImmediatelyDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances() in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)

		/**
		 * Get only the immediately next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getImmediatelyDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	      let conns = IntegrationTSNodeConnection.allInstances()
	      				  ->select(c | c.oclContainer = ic) in
	      				  self.getImmediatelyDownstreamUoPInstancesImpl(conns)


	    def: getImmediatelyDownstreamUoPInstancesImpl(conns: Collection(IntegrationTSNodeConnection)) : Set(IntegrationUoPInstance) =
	               conns  ->select(c | self.outPort->includes(c.source))
	                      ->collect(destination)
	                      ->selectByKind(IntegrationUoPInputEndPoint)
	                      ->collect(oclAsType(IntegrationTSNodePortBase))
	                      ->collect(getParentUoPInstance())
	                      ->asSet()

		/*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "upstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * upstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedUpstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances() in
	    	let prevNodes = self.getPreviousNodes() in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked previous UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedUpstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyUpstreamUoPInstances(ic) in
	    	let prevNodes = self.getPreviousNodes(ic) in
	    	let instancesViaNodes = prevNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedUpstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

	    /*
	     * Helper method that gets the set of IntegrationUoPInstances that are 
	     * "downstream" from a given IntegrationUoPInstance via links that only connect
	     * to 'intermediate' IntgrationTransportNodes (in other words, these are the 
	     * downstream UoPInstances whose links to 'self' do not go through another UoPInstance)
	     */
	    def: getLinkedDownstreamUoPInstances() : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances() in
	    	let nextNodes = self.getNextNodes() in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances())
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()

		/**
		 * Get only the linked next UoPInstances that you can by following links in the
		 * specified IntegrationContext
		 */
	    def: getLinkedDownstreamUoPInstances(ic: IntegrationIntegrationContext) : Set(IntegrationUoPInstance) =
	    	let immediateInstances = self.getImmediatelyDownstreamUoPInstances(ic) in
	    	let nextNodes = self.getNextNodes(ic) in
	    	let instancesViaNodes = nextNodes->iterate(n: IntegrationTransportNode; result: Set(IntegrationUoPInstance) = Set{} |
	    		result->includingAll(n.getLinkedDownstreamUoPInstances(ic))
	    	) in
			immediateInstances->union(instancesViaNodes)->asSet()
	
	
		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are
		 */
		def: getAllDownstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllDownstreamUoPInstances()))
			)

		/**
		 * Get all the downstream UoPInstances, no matter how far down the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllDownstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedDownstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllDownstreamUoPInstances(ic)))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are.
		 */
		def: getAllUpstreamUoPInstances(): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances() in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllUpstreamUoPInstances()))
			)

		/**
		 * Get all the upstream UoPInstances, no matter how far up the chain they are, that
		 * you can reach using only links in the specified IntegrationContext
		 */
		def: getAllUpstreamUoPInstances(ic: IntegrationIntegrationContext): Set(IntegrationUoPInstance) =
			let linkedDUI = self.getLinkedUpstreamUoPInstances(ic) in
			linkedDUI->iterate(inst: IntegrationUoPInstance; result: Set(IntegrationUoPInstance) = Set{}|
				result->includingAll(inst->closure(getAllUpstreamUoPInstances(ic)))
			)
				
endpackage
